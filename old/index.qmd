---
title: "Choice of Brand for Crackers"
author: "Mario Camacho"
format:
  html:
    toc: TRUE
    toc-location: left
    toc-title: Índice
    toc-expand: TRUE
editor: visual
page-layout: full
knitr:
  opts_chunk: 
    R.options:
      width: 110
code-fold: true
---

```{r}
#| output: false
library(tidyverse)
library(Ecdat)
library(rpivotTable)
library(VGAM)
```

# Database

## Descripción

En este caso de uso utilizamos la base de datos Cracker del paquete Ecdat sobre la elección de un individuo de una marca de galletas saladas entre cuatro opciones posibles. (Sunshine, Kleebler, Nabisco y Private)

La base de datos contiene 3.292 registros y dentro de cada fila tenemos:

-   **id**: individuals identifiers\
-   **choice**: one of sunshine, kleebler, nabisco, private\
-   **disp.z**: is there a display for brand z ?\
-   **feat.z**: is there a newspaper feature advertisement for brand z ?\
-   **price.z**: price of brand z

```{r}
summary(Cracker)
```

## Datos por individuo

Se han recogido datos de 136 individuos. Cada individuo tiene de media 21 registros.

```{r}
Cracker |> select(id) |> table() |> as.data.frame() |> select(Freq) |> summary()
```

Tomamos de ejemplo algunos de los registros del id 1.

```{r}
Cracker |> filter(id==1) |> head(5)
```

## Distribución de las preferencias

Para cada usuario contamos el número de veces que ha elegido cada una de las marcas.

```{r}
data_0 <- 
Cracker |> select(id, choice) |> group_by_all() |> count(,.drop = FALSE)  |> ungroup() |> mutate(p = n/sum(n), .by=id) |> 
  #mutate(scale = scale(p, scale = FALSE), .by=id) |> 
  arrange(id,-n) |> mutate(preference = row_number(), .by=id)
```

El individuo 1 ha elegido la marca Nabisco en el 87.5 % de las veces.

```{r}
#| echo: false
data_0 |> head(8)
```

La distribución de la preferencia de cada marca:

```{r}
#| layout-ncol: 3
data_0 |> select(choice, preference) |> table() |> addmargins()
round(
  data_0 |> select(choice, preference) |> table() |> prop.table(1)*100, 2
) |> addmargins()
```

## Escala

Creamos una escala teniendo en cuenta las preferencias del individuo e incluyendo el porcentaje de veces que elige cada una de las marcas sobre el total de sus elecciones.

```{r}
data_1 <- 
data_0 |> mutate(scale = scale(p, scale = FALSE), .by=id)
```

Esta escala tiene una relación directa con la proporción de cada una de las elecciones. Se mueve entre los valores -0.25 y 0.75.

-   El valor -0.25 si esa marca nunca ha sido elegida por el individuo (p=0).
-   El valor 0.75 si es la única marca elegida por el usuario (p=1).

```{r}
data_1 |> select(choice, p, scale) |> summary()
```

Si las elecciones fueran fruto del azar, cada marca sería elegida un 25 % por cada individuo. Con la escala creado cuantificamos cuánto se desvía la proporción de cada elección sobre este porcentaje esperado.

```{r}
data_1 |> filter(id==1)
```

Los individuos 7 y 123 han hecho un total de 17 elecciones siendo su marca preferida Nabisco.

```{r}
data_1 |> filter(id %in% c(7,123))
```

# Análisis exploratorio

## Eliminación datos confusos

Existen tres registros donde el precio de la marca Nabisco es cero. Puede deberse a alguna oferta que no tengamos recogida o error en los datos. Eliminamos estos registros

```{r}
#| echo: fenced
Cracker |> filter(price.nabisco==0) |> select(c(contains('nabisco'),'choice'))
Cracker_clean <- Cracker |> filter(price.nabisco>0) 
```

## Distribución del precio

```{r}
summary(Cracker_clean |> select(contains('price')))
```

Definimos el precio de la marca elegida por el usuario y lo enfrentamos al precio medio de las elecciones que tenía el individuo.

```{r}
data_2 <- Cracker_clean |> mutate(precio_medio = (price.sunshine + price.kleebler + price.nabisco + price.private) / 4,
                                         precio_preferencia = case_when(choice == "sunshine" ~ price.sunshine,
                                                                        choice == "kleebler" ~ price.kleebler,
                                                                        choice == "nabisco" ~ price.nabisco,
                                                                        choice == "private" ~ price.private),
                                         id=factor(id))
                                         # |>
  #select(precio_preferencia, precio_medio, id, choice)
```

::: callout-important
Ajustar gráfico a ancho de la página cambiar título leyenda
:::

La marca Private casi siempre tiene un precio superior al precio medio de las cuatro marcas cuando es la marca que el individuo prefiere. Aquellos casos donde la marca elegida es la marca Nabisco, el precio de esta elección casi siempre es inferior al precio medio de las cuatro marcas.

```{r}
#| warning: false
data_2 |> ggplot() + geom_point(aes(x=precio_preferencia, y=precio_medio, colour = factor(choice))) +
   geom_abline(intercept = 0) + xlim(30, 150) + ylim(30, 150)
```

# Modelo predictivo

## Objetivo

Queremos predecir la preferencia de un individuo entre cuatro posibles marcas de galletas saladas en función de las características de venta de cada una de las marcas.

## Enfoque del modelo

La variable respuesta es la variable *choice*. Una variable nominal con cuatro categorías que identifica la marca preferida de cada individuo.

Tenemos dos variables dicotómicas para cada marca. La variable *display* indica si la marca tenía un display o no. Y la variable *feat* indica si había un anuncio en el periódico o no.

También la variable continua *price* sobre el precio de la marca.

## Train y test

```{r}
set.seed(1234)
test_0 <- Cracker_clean |>
  slice_sample(prop = 0.10, by = c(id))
train_0 <- anti_join(Cracker_clean |> mutate(r=row_number()), test_0 |> mutate(r=row_number()), by='r') |> select(-r)
```

## Modelo respuesta múltiple nominal

Usamos la librería VGAM para un modelo repuesta múltiple nominal y donde debemos elegir una categoría de referencia. El resultado del modelo indicará cómo de probable es la elección de cada una de las tres marcas en relación a la categoría de referencia para cada individuo en función.

[**Modelo 1**]{.underline}

```{r}
modelo1 <- vglm((choice) ~ disp.sunshine + disp.kleebler + disp.nabisco + disp.private + feat.sunshine +
feat.kleebler + feat.nabisco + feat.private + price.sunshine + price.kleebler + price.nabisco + price.private,
family=multinomial(refLevel='private'),
                data = train_0)
summary(modelo1)
```

[**Modelo 2**]{.underline}

```{r}
# sin disp.sunshine, feat.sunshine
modelo2 <- vglm((choice) ~ disp.kleebler + disp.nabisco + disp.private +
                  feat.kleebler + feat.nabisco + feat.private + price.sunshine + price.kleebler + price.nabisco + price.private,
                family=multinomial(refLevel='private'),
                data = train_0)
summary(modelo2)
```

[**Coeficientes modelo final (modelo 2)**]{.underline}

```{r}
coef(modelo2, matrix = TRUE)
```

```{r}
mycol <- c("red","darkgreen","blue")

par(mfrow=c(3,3))
plotvgam(modelo2, se=TRUE, scale=12,
         lcol=mycol[1], scol=mycol[1], which.term=1)
plotvgam(modelo2, se=TRUE, scale=12,
         lcol=mycol[2], scol=mycol[2], which.term=2)
plotvgam(modelo2, se=TRUE, scale=12,
         lcol=mycol[3], scol=mycol[3], which.term=3)
```

Comparamos el primer modelo con el segundo modelo.

```{r}
#| echo: fenced
# Comparamos el primer modelo con el segundo modelo
deviance(modelo1) - deviance(modelo2)

(dfdiff <- df.residual(modelo2) - df.residual(modelo1))

1-pchisq(deviance(modelo1) - deviance(modelo2), df=dfdiff)
```

Enfocamos el modelo con medidas repetidas, ya que para cada individuo contamos con más de una observación.

Usamos la librería VGAM para un modelo mixto de repuesta múltiple nominal y donde debemos elegir una categoría de referencia. El resultado del modelo indicará cómo de probable es la elección de cada una de las tres marcas en relación a la categoría de referencia para cada individuo en función.

El modelo saturado inicial cuenta con una parte aleatoria. \* Pendiente aleatoria. Nos dará información sobre si cada

modelo443 \<- vglm(puntuacion \~ tratamiento\*semana, family=cumulative(link = logitlink), data = mitema4) summary(modelo443)
